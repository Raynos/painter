<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
		<script src="//localhost:9090"></script>
	</head>

	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1> Serverless apps. </h1>

					By <a href="http://github.com/Raynos">
						github.com/Raynos
					</a>
					<br/>
					<a href="https://twitter.com/raynos2">
						@Raynos2
					</a>

					<aside class="notes">
						Hi guys!

						Let's get cracking on server less apps.

						But first, Who is this guy and why should
							you listen to him!

						For those who don't know me I do a lot of
							work on javascript & node.js,
							especially the overlap of those two.

						I've authored over a hundred modules and
							my recent work includes making
							webrtc & indexeddb easy. That's what
							we are talking about today.
					</aside>
				</section>
				<section>
					<section>
						<h1>You want to build server-less apps?! </h1>
					</section>
					<section>
						<h1> Wait, why would you want to? </h1>
					</section>

					<section>
						<h1> server is complex </h1>
					</section>

					<section>
						<h1> Strive for Simplicity </h1>
					</section>

					<aside class="notes">
						For me it's really simple. Servers are a
							pain to set up. You guys all do HTML5

						You know how hard it is to build complex,
							cool and maintainable HTML5 apps.

						A big part of that complexity is all the
							Ajax, REST and server side communication

						Especially when doing realtime stuff. You
							have to set up all these servers and
							scale them and make sure they stay up.

						And the worst part is all that code and
							logic duplication between client and
							server. (Especially when your using
							node.js)

						So let's make that simpler.
					</aside>
				</section>
				<section>
					<section>
						<h1> There is data it exists. </h1>
					</section>
					<section>
						<h1> That's it. </h1>
					</section>

					<aside class="notes">
						So what does simpler mean.

						To me it means lets make the data simple.

						Because no matter what you do the servers
							are all about the data and state,
							especially with those heavy client-side
							apps.

						To this extend it's time for a paradigm shift.

						There is data it exists. That's it. You don't
							care where the data is. You don't care
							where it comes from, you don't care about
							who has it or who owns it.

						All you have to do is say there is data, it
							exists. And then you just manipulate the
							data and build your app on top of that.

						I'm afraid I can't spoil the punchline of how
							you achieve this quite yet so we're going
							to have to do this step by step.
					</aside>
				</section>
				<section>
					<section>
						<h1> P2P </h1>
					</section>
					<section>
						<ul>
							<li> <h2> WebRTC </h2> </li>
							<li> <h2> topologies </h2> </li>
						</ul>
					</section>

					<aside class="notes">
						There is no server. Cut out the middleman
							just talk to each other and exchange
							data and messages.

						Recently the server has just become a dumb
							CRUD end point or message broadcaster.

						Screw that. Cut it out completely.

						So what's needed to do p2p in browsers.

						You need a way to make a peer to peer
							connection.

						That allows one peer to talk to another peer.

						And you need a way to let multiple peers talk
							to each other in one group conversation.

						Which basically mean you have a network of peers
							and you want to organize them into some
							kind of network topology
					</aside>
				</section>
				<section>
					<section>
						<img src="http://upload.wikimedia.org/wikipedia/commons/6/66/NetworkTopology-Star.png"></img>
					</section>
					<section>
						<img src="http://upload.wikimedia.org/wikipedia/commons/3/3c/NetworkTopology-FullyConnected.png"></img>

						<br/>
						<a href="https://github.com/Raynos/topology"> More topologies </a>
					</section>
					<section>
						<img src="http://www.pjort.com/randpeer/p2p-slides/img011.png"></img>

						<div> From rand peer. dead link :( </div>
					</section>

					<aside class="notes">
						A network topology simply describes how multiple
							nodes in your p2p network connect to each
							other.

						In your normal server client app it would look
							like this. The server is the center and all
							your clients connect to the server.

						Really simple until the server goes down.

						This is the main advantage of p2p, its tolerant
							of network partitions. If a node goes down
							you don't care.

						There are many different network topologies that
							you can use.

						The simplest one thats very tolerant to network
							partitions is a fully connected network.

						It's really easy to do, just connect to everyone.
							The downside is that it's a terrible waste of
							bandwidth and doesn't scale.

						A better solution would be a random network.
							You randomly connected to limited set of
							other peers.
					</aside>
				</section>
				<section>
					<h1> DEMO TIME </h1>
					<a href="https://github.com/Raynos/painter/tree/master/examples/chat">Chat demo</a>
				</section>
				<section>
					<section>
						<h1>Databases</h1>
					</section>
					<section>
						<h1>Level DB</h1>
					</section>
					<section>
						<pre><code>
db.get(key, function (err, value) {
    console.log("got me a value", value)
})
						</code></pre>
					</section>
					<section>
						<pre><code>
db.put(key, value, function (err) {
    console.log("set the value!")
})
						</code></pre>
					</section>
					<section>
						<pre><code>
db.del(key, function (err) {
    console.log("deleted the key!")
})
						</code></pre>
					</section>
					<section>
						<pre><code>
db.readStream({ start: "bar", end: "foo" })
    .on("data", function (value) {
        console.log("one of the values " +
           "between bar and foo")
    })
						</code></pre>
					</section>
					<section>
						<h1> Blazing fast index === epic range queries </h1>
					</section>
					<aside class="notes">
						Being able to peer to peer connections is
							pretty cool. But passing messages around
							and managing history / state yourself gets
							a bit tedious.

						What if you could just have a simple clean database
							API in your app.

						Enter levelDB. Now level db is cool because it's
							dead simple. It's literally a few commands,
							get, put, del, batch and range queries.

						LevelDB solves a single hard problem, it's got
							blazing fast range queries because it has a single
							index. And it's blazing fast.
					</aside>
				</section>
				<section>
					<section>
						<h1> Hack all the databases </h1>
					</section>
					<section>
						<h1> Freedom from monolithic databases </h1>
					</section>
					<section>
						<h1> Plugin ecosystem === build your own database </h1>
					</section>
					<aside class="notes">
						LevelDB is a real javascript database. NPM style.

						It does just the hard problem and leaves the rest out
							to you.

						Which means we are free from monolithic databases.

						No longer do you need a database vendor like oracle or
							10gen to tell you what kind of database you want
							and what kind of trade offs are needed.

						Do you want a database where you can stream changes from? Easy. 100 lines of javascript on top of leveldb.

						Want map reduce? 200 lines of JS on top of leveldb.

						Want database replication? 200 lines of JS.

						Want search queryes? 200 lines of JS

						Want multiple indexes? 200 lines of JS

						Want spatial indexes? 200 lines of JS.

						Now, here's the kicker. Chrome implements indexeddb
							using leveldb. Unfortunally indexeddb is the worst
							DOM api ever. Like literally the worst, I've dealt
							with all of them.

						Thankfully I've written an abstraction on top of
							indexeddb that emulates the leveldb API.

						So you get simplicity and hackability back!
					</aside>
				</section>
				<section>
					<h1> ANOTHER DEMO </h1>
					<a href="https://github.com/Raynos/painter/tree/master/examples/paint">Paint demo</a>
				</section>
				<section>
					<h1> END </h1>
					By <a href="http://github.com/Raynos">
						github.com/Raynos
					</a>
					<br/>
					<a href="https://twitter.com/raynos2">
						@Raynos2
					</a>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
